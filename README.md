
# Telekinesis Game: Search Algorithms Implementation

## Problem Description

The problem is to implement a telekinesis game in which a telekinetic agent has the ability to move furniture within a room represented as an n Ã— m grid. The furniture can be either horizontally or vertically placed and occupies two or three grid cells. The agent itself occupies two horizontal cells in the second row from the top of the room and can move left or right. The goal of the game is to create a plan using search algorithms to move the furniture in such a way that the agent can reach the only exit on the right-most cell of the second row.
## visual repreesentation of the grid
![image](https://user-images.githubusercontent.com/86190960/122679985-0b0b6b00-d1e5-11eb-9b0a-8b8b0b8b6b0a.png)

## Implementation Overview

The implementation involves generating a random grid with furniture, creating a search problem specific to this telekinesis game, and applying various search algorithms to find a winning plan for the agent. The provided implementation of the search-tree node ADT is geared towards solving the telekinesis game using search algorithms like A* and Greedy search.

## Key Aspects and Design Choices

1. **State Representation:**
   - The `Grid` class is used to represent the state of the telekinesis game. It stores the grid configuration, the position of the agent, and the list of furniture objects.
   - The state is converted to a string (`strState`) to facilitate easy comparison and hashing.

2. **Node Hierarchy:**
   - The `Node` class is designed to form a tree-like structure where each node can have multiple children (leaves). Each node represents a particular state in the game.
   - The nodes are linked through the `parentNode` reference, allowing easy traversal from child to parent nodes.

3. **Node Expansion:**
   - The `expand()` method generates child nodes by applying valid moves to the furniture pieces in the current state.
   - If a furniture piece is oriented vertically, two child nodes are generated by moving the furniture up and down.
   - If a furniture piece is oriented horizontally, two child nodes are generated by moving the furniture left and right.
   - This node expansion process explores different possible configurations of the game, creating a search tree.

4. **Goal Test:**
   - The `goaltest()` method checks if the current state represents the goal state. In the context of the telekinesis game, the goal state is when the agent can reach the exit on the right-most cell of the second row.
   - The goal test is an essential part of the search algorithm, as it allows the search process to terminate once the goal state is found.

5. **Heuristic Calculation:**
   - The `setHeuristic()` method calculates heuristic values (`h1` and `h2`) for each node. These heuristics are used in A* and Greedy search algorithms to guide the search towards the goal state efficiently.
   - `h1` estimates the cost from the current state to the goal state by considering the obstacles (furniture) that the agent needs to bypass.
   - `h2` estimates the cost by considering the number of vertical furniture pieces that need to be moved to open the agent's path.

6. **Comparator Classes:**
   - The provided comparator classes (`Sortbycost`, `SortbyaStar_cost`, `Sortbyhersic`) allow sorting nodes based on their costs and heuristic values. These comparators are utilized in priority queues to select the most promising nodes during the search.

7. **Parent-Child Relationship:**
   - Each node maintains a reference to its parent node using the `parentNode` field. This parent-child relationship is crucial for tracing back the path from the goal node to the initial state once the goal is found.
## implementation of the Telekinesis problem.
1. `Grid` Class: The `Grid` class represents the grid environment where the furniture movement takes place. It includes methods for generating the grid, printing the grid in a visual format, moving furniture in different directions (e.g., up, down, left, right), and saving the grid to a file. The grid is represented as a 2D array of integers, where each value indicates the type of cell (e.g., empty cell, agent body, furniture).

2. `Furniture` Class: The `Furniture` class represents individual pieces of furniture that can be moved within the grid. Each furniture object stores information such as its position (x, y), length, and orientation (horizontal or vertical).

3. `Node` Class: The `Node` class is used to represent nodes in the search tree. Each node contains a reference to the current state of the grid, a list of possible successor nodes (leaves), the cost associated with reaching that node, depth in the search tree, and other relevant attributes. The `expand()` method generates successor nodes based on possible movements of the furniture.

4. `Search` Class: The `Search` class contains various search algorithms to solve the Telekinesis problem. The implemented algorithms include Breadth-First Search (BFS), Depth-First Search (DFS), Depth-Limited Search (DLS), Iterative Deepening Search (IDS), Uniform Cost Search (UCS), A* Search, and Greedy Search. These algorithms explore the search space to find a sequence of movements that lead to the goal state.

5. Heuristics: In your implementation, you have used two heuristics: `h1()` and `setHeuristic()`. Heuristics are used in informed search algorithms (A* and Greedy Search) to estimate the distance from a node to the goal state. The `h1()` method provides a simple heuristic that returns 0, effectively turning A* and Greedy Search into Uniform Cost Search and BFS, respectively. The `setHeuristic()` method calculates a more sophisticated heuristic that considers the number of obstacles and their positions.

6. Search Algorithms: Each search algorithm in the `Search` class explores the search space by expanding nodes, generating successor nodes, and adding them to the search queue. The algorithms use various data structures (e.g., `ArrayList`, `LinkedList`, `HashSet`) to manage the search process efficiently.

7. Solution: The `Solution` class is used to store the results of each search algorithm, including the expansion sequence, remaining nodes in the queue, the goal node (if found), and a boolean indicating whether a solution exists.

## how you implemented the various search algorithms

1. Breadth-First Search (BFS):
   - You used an `ArrayList` called `queue` to store the nodes to be expanded.
   - You used an `ArrayList` called `uniqueStates` to keep track of unique grid states to avoid duplicates.
   - The `expandSequence` is an `ArrayList` that stores the sequence of nodes expanded during the search process.
   - You applied the BFS strategy by adding newly generated nodes at the end of the queue using `queue.add(newNode)`.
   - You used `queue.remove(0)` to retrieve and remove the first node from the queue (frontier) for expansion.
   - You checked for the goal state using the `node.goaltest()` method.
   - The BFS search process continues until the queue becomes empty.

2. Depth-First Search (DFS):
   - Similar to BFS, you used an `ArrayList` called `queue` to store the nodes to be expanded.
   - You used the `uniqueStates` list to keep track of unique grid states.
   - The `expandSequence` list stores the sequence of nodes expanded during the search process.
   - You applied the DFS strategy by adding newly generated nodes at the beginning of the queue using `queue.add(0, newNode)`.
   - You used `queue.remove(0)` to retrieve and remove the first node from the queue (frontier) for expansion.
   - Like BFS, you checked for the goal state using the `node.goaltest()` method.
   - The DFS search process continues until the queue becomes empty.

3. Depth-Limited Search (DLS):
   - In the `depthLimited` method, you used a `Queue` (specifically, a `LinkedList`) called `queue` to store the nodes to be expanded.
   - You used a `HashSet` called `uniqueStates` to keep track of unique grid states to avoid duplicates.
   - The `expandSequence` is an `ArrayList` that stores the sequence of nodes expanded during the search process.
   - You set a depth limit (`depthLimit`) to control the depth of exploration in the search tree.
   - You applied the DFS strategy with depth limitation by not expanding nodes beyond the specified depth limit.
   - If a node's depth is less than the depth limit, its successors are added to the queue for further exploration.
   - You checked for the goal state using the `node.goaltest()` method.
   - The DLS process continues until the queue becomes empty.

4. Iterative Deepening Search (IDS):
   - In the `iterativeDeepening` method, you iteratively apply the `depthLimited` method with increasing depth limits until a solution is found.
   - The `iterativeDeepening` method returns a `Solution` object with the results of the search, including the expansion sequence and whether a solution was found.
   - By repeatedly performing DLS with increasing depth limits, you ensure that you explore the search space deeper and deeper until a solution is found.

5. Uniform Cost Search (UCS):
   - You used an `ArrayList` called `queue` to store the nodes to be expanded.
   - You used an `ArrayList` called `uniqueStates` to keep track of unique grid states to avoid duplicates.
   - The `expandSequence` is an `ArrayList` that stores the sequence of nodes expanded during the search process.
   - You implemented UCS by sorting the queue based on the cost of nodes using the `Sortbycost` comparator.
   - Nodes with lower costs are expanded first to prioritize paths with lower cumulative costs.
   - The UCS search process continues until the queue becomes empty.

6. A* Search:
   - You used an `ArrayList` called `queue` to store the nodes to be expanded.
   - You used an `ArrayList` called `uniqueStates` to keep track of unique grid states to avoid duplicates.
   - The `expandSequence` is an `ArrayList` that stores the sequence of nodes expanded during the search process.
   - You implemented A* search by sorting the queue based on the A* cost of nodes using the `SortbyaStar_cost` comparator.
   - The A* cost combines the actual cost to reach the node and the estimated cost from the node to the goal state using the heuristic function.
   - Nodes with lower A* costs are expanded first, leading to the exploration of more promising paths.
   - The A* search process continues until the queue becomes empty.

7. Greedy Search:
   - You used an `ArrayList` called `queue` to store the nodes to be expanded.
   - You used an `ArrayList` called `uniqueStates` to keep track of unique grid states to avoid duplicates.
   - The `expandSequence` is an `ArrayList` that stores the sequence of nodes expanded during the search process.
   - You implemented Greedy search by sorting the queue based on the greedy cost of nodes using the `Sortbyhersic` comparator.
   - The greedy cost is based solely on the heuristic function and represents the estimated distance to the goal state.
   - Nodes with lower greedy costs are expanded first, prioritizing nodes that seem to be closer to the goal state.
   - The Greedy search process continues until the queue becomes empty.




.
## Performance Comparison

The performance of various search algorithms was tested and compared based on the number of search tree nodes expanded. The algorithms that were implemented and compared include:

1. Breadth-First Search
2. Depth-First Search
3. Iterative Deepening Search
4. Uniform-Cost Search
5. Greedy Search with Two Heuristics
6. A* Search with Two Admissible Heuristics



## Conclusion

The implementation provides a solid foundation for implementing various search algorithms to find an optimal path for the agent to reach the goal state in the telekinesis game. The use of priority queues and heuristic functions allows for more efficient exploration of the search space, which is essential for solving complex problems.

The performance comparison helps identify the most effective search algorithm for the given telekinesis game, providing valuable insights into the strengths and weaknesses of each approach. With this implementation and analysis, players can enjoy solving the telekinesis game efficiently and find the optimal plan to guide the agent to the exit.