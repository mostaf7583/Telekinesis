Sure, here's the report converted to Markdown format:

# Telekinesis Game: Search Algorithms Implementation

## Problem Description

The problem is to implement a telekinesis game in which a telekinetic agent has the ability to move furniture within a room represented as an n Ã— m grid. The furniture can be either horizontally or vertically placed and occupies two or three grid cells. The agent itself occupies two horizontal cells in the second row from the top of the room and can move left or right. The goal of the game is to create a plan using search algorithms to move the furniture in such a way that the agent can reach the only exit on the right-most cell of the second row.

## Implementation Overview

The implementation involves generating a random grid with furniture, creating a search problem specific to this telekinesis game, and applying various search algorithms to find a winning plan for the agent. The provided implementation of the search-tree node ADT is geared towards solving the telekinesis game using search algorithms like A* and Greedy search.

## Key Aspects and Design Choices

1. **State Representation:**
   - The `Grid` class is used to represent the state of the telekinesis game. It stores the grid configuration, the position of the agent, and the list of furniture objects.
   - The state is converted to a string (`strState`) to facilitate easy comparison and hashing.

2. **Node Hierarchy:**
   - The `Node` class is designed to form a tree-like structure where each node can have multiple children (leaves). Each node represents a particular state in the game.
   - The nodes are linked through the `parentNode` reference, allowing easy traversal from child to parent nodes.

3. **Node Expansion:**
   - The `expand()` method generates child nodes by applying valid moves to the furniture pieces in the current state.
   - If a furniture piece is oriented vertically, two child nodes are generated by moving the furniture up and down.
   - If a furniture piece is oriented horizontally, two child nodes are generated by moving the furniture left and right.
   - This node expansion process explores different possible configurations of the game, creating a search tree.

4. **Goal Test:**
   - The `goaltest()` method checks if the current state represents the goal state. In the context of the telekinesis game, the goal state is when the agent can reach the exit on the right-most cell of the second row.
   - The goal test is an essential part of the search algorithm, as it allows the search process to terminate once the goal state is found.

5. **Heuristic Calculation:**
   - The `setHeuristic()` method calculates heuristic values (`h1` and `h2`) for each node. These heuristics are used in A* and Greedy search algorithms to guide the search towards the goal state efficiently.
   - `h1` estimates the cost from the current state to the goal state by considering the obstacles (furniture) that the agent needs to bypass.
   - `h2` estimates the cost by considering the number of vertical furniture pieces that need to be moved to open the agent's path.

6. **Comparator Classes:**
   - The provided comparator classes (`Sortbycost`, `SortbyaStar_cost`, `Sortbyhersic`) allow sorting nodes based on their costs and heuristic values. These comparators are utilized in priority queues to select the most promising nodes during the search.

7. **Parent-Child Relationship:**
   - Each node maintains a reference to its parent node using the `parentNode` field. This parent-child relationship is crucial for tracing back the path from the goal node to the initial state once the goal is found.
## implementation of the Telekinesis problem.
1. `Grid` Class: The `Grid` class represents the grid environment where the furniture movement takes place. It includes methods for generating the grid, printing the grid in a visual format, moving furniture in different directions (e.g., up, down, left, right), and saving the grid to a file. The grid is represented as a 2D array of integers, where each value indicates the type of cell (e.g., empty cell, agent body, furniture).

2. `Furniture` Class: The `Furniture` class represents individual pieces of furniture that can be moved within the grid. Each furniture object stores information such as its position (x, y), length, and orientation (horizontal or vertical).

3. `Node` Class: The `Node` class is used to represent nodes in the search tree. Each node contains a reference to the current state of the grid, a list of possible successor nodes (leaves), the cost associated with reaching that node, depth in the search tree, and other relevant attributes. The `expand()` method generates successor nodes based on possible movements of the furniture.

4. `Search` Class: The `Search` class contains various search algorithms to solve the Telekinesis problem. The implemented algorithms include Breadth-First Search (BFS), Depth-First Search (DFS), Depth-Limited Search (DLS), Iterative Deepening Search (IDS), Uniform Cost Search (UCS), A* Search, and Greedy Search. These algorithms explore the search space to find a sequence of movements that lead to the goal state.

5. Heuristics: In your implementation, you have used two heuristics: `h1()` and `setHeuristic()`. Heuristics are used in informed search algorithms (A* and Greedy Search) to estimate the distance from a node to the goal state. The `h1()` method provides a simple heuristic that returns 0, effectively turning A* and Greedy Search into Uniform Cost Search and BFS, respectively. The `setHeuristic()` method calculates a more sophisticated heuristic that considers the number of obstacles and their positions.

6. Search Algorithms: Each search algorithm in the `Search` class explores the search space by expanding nodes, generating successor nodes, and adding them to the search queue. The algorithms use various data structures (e.g., `ArrayList`, `LinkedList`, `HashSet`) to manage the search process efficiently.

7. Solution: The `Solution` class is used to store the results of each search algorithm, including the expansion sequence, remaining nodes in the queue, the goal node (if found), and a boolean indicating whether a solution exists.

.
## Performance Comparison

The performance of various search algorithms was tested and compared based on the number of search tree nodes expanded. The algorithms that were implemented and compared include:

1. Breadth-First Search
2. Depth-First Search
3. Iterative Deepening Search
4. Uniform-Cost Search
5. Greedy Search with Two Heuristics
6. A* Search with Two Admissible Heuristics



## Conclusion

The implementation provides a solid foundation for implementing various search algorithms to find an optimal path for the agent to reach the goal state in the telekinesis game. The use of priority queues and heuristic functions allows for more efficient exploration of the search space, which is essential for solving complex problems.

The performance comparison helps identify the most effective search algorithm for the given telekinesis game, providing valuable insights into the strengths and weaknesses of each approach. With this implementation and analysis, players can enjoy solving the telekinesis game efficiently and find the optimal plan to guide the agent to the exit.